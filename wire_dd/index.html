<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bezier Connection Demo (Multiple Boxes)</title>
    <style>
        .wrapper {
            height: 100%;
            padding: 20px;
            margin: 40px;

        }
        .wrap{
            width: 1024px;
            height: 768px;
            border: 1px solid black;
            position: relative;
            margin: 0 auto;
        }

        .box {
            width: 33px;
            height: 33px; border-radius: 50%;
            background-color: salmon;
            position: absolute;
            cursor: pointer;
        }

        #box1 {
            top: 50px;
            left: 50px;
        }

        #box2 {
            top: 250px;
            left: 150px;
        }

        #box3 {
            top: 150px;
            right: 50px;
        }
        #box4 {
        top: 400px;
        left: 250px;
    }

    #box5 {
        top: 150px;
        left: 400px;
    }

        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        path {
            fill: none;
            stroke: black;
            stroke-width: 2;
        }
    </style>
</head>

<body>
    <div class="wrapper">
        <p>Lorem ipsum dolor sit, amet consectetur adipisicing elit. Explicabo quasi iste dolores magni odit recusandae quibusdam tempore quod illum incidunt placeat corrupti, debitis hic eveniet totam necessitatibus voluptates. Atque voluptas dicta ipsa sapiente aspernatur saepe est hic facilis, itaque velit nam aliquid ullam tempora deleniti architecto quisquam voluptatibus inventore fugit dolores animi rerum labore maxime. Dolor est accusamus soluta velit vel suscipit iusto quibusdam dolores. Sint, sed quis laborum consectetur facere ab veritatis commodi quidem ipsum explicabo? Facere magni tempore dignissimos commodi eveniet quaerat odio est? Eum quisquam doloremque ipsam ratione, iure omnis sint excepturi rem voluptatem voluptate, beatae amet.</p>
        <div class="wrap">
            <div id="box1" class="box"></div>
            <div id="box2" class="box"></div>
            <div id="box3" class="box"></div>
            <div id="box4" class="box"></div>
            <div id="box5" class="box"></div>
        </div>
    </div>

<svg>
  <path id="connector" d=""></path>
</svg>

<svg id="connectorContainer"></svg>

<script>
function connectElements(elem1, elem2) {
    const path = createSVGLine(
        getCenterOfElement(elem1),
        getCenterOfElement(elem2)
    );
    document.getElementById('connectorContainer').appendChild(path);
    path.setAttribute('data-connected-from', elem1.id);
    path.setAttribute('data-connected-to', elem2.id);
    const connectionKey = elem1.id + "-" + elem2.id;
    connectedPaths[connectionKey] = path;
    console.log("Connection created with key:", connectionKey); // キーをログに出力
}

    
    function getCenterOfElement(elem) {
        const rect = elem.getBoundingClientRect();
        return {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
        };
    }
    
    function createSVGLine(coords1, coords2) {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const d = `M${coords1.x},${coords1.y} L${coords2.x},${coords2.y}`;
        path.setAttribute('d', d);
        path.setAttribute('stroke', 'black');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('fill', 'none');
        return path;
    }
    
        let startElem = null;
        let tempPath = null;
        let connectedPaths = {};
    
        const path = document.getElementById('connector');
    
        function startConnection(e) {
        e.preventDefault();
    
        // 既に接続済みの要素であるかの確認
        if (e.target.classList.contains('connected')) {
            // 既存の結線を削除
            const existingPath = connectedPaths[e.target.id];
            if (existingPath && document.getElementById('connectorContainer').contains(existingPath)) {
                document.getElementById('connectorContainer').removeChild(existingPath);
                delete connectedPaths[e.target.id];
            }
    
            // Reset the connected status of both the drag source and drop target
            if (existingPath) {
                const connectedElemId = existingPath.getAttribute('data-connected-to');
                if (connectedElemId) {
                    const connectedElem = document.getElementById(connectedElemId);
                    if (connectedElem) {
                        connectedElem.classList.remove('connected');
                        delete connectedPaths[connectedElemId];
                    }
                }
                e.target.classList.remove('connected');
            }
        }
    
        startElem = e.target;
    
        if (e.type === "mousedown") {
            document.addEventListener("mousemove", drawBezier);
            document.addEventListener("mouseup", endConnection);
        } else if (e.type === "touchstart") {
            document.addEventListener("touchmove", drawBezier);
            document.addEventListener("touchend", endConnection);
        }
    
        tempPath = createPathElement();
        document.getElementById('connectorContainer').appendChild(tempPath);
    }
    
        function createPathElement() {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', 'black');
            path.setAttribute('stroke-width', '2');
            return path;
        }
    
        function drawBezier(e) {
            e.preventDefault();
    
            if (!startElem) return;
    
            const { x: endX, y: endY } = getCoordinates(e);
            const startX = startElem.getBoundingClientRect().left + 16.5;
            const startY = startElem.getBoundingClientRect().top + 16.5;
            
            const controlX = (startX + endX) / 2;
            const controlY = startY;
    
            const d = `M ${startX} ${startY} Q ${controlX} ${controlY}, ${endX} ${endY}`;
            tempPath.setAttribute('d', d);
        }
    
        function getCoordinates(e) {
            if (e.type.startsWith('touch')) {
                if(e.changedTouches && e.changedTouches.length) {
                    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
                }
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }
    
        function endConnection(e) {
            e.preventDefault();
    
            if (!startElem) return;
    
            const endElem = document.elementFromPoint(getCoordinates(e).x, getCoordinates(e).y);
    
            if (endElem.classList.contains('box') && 
                endElem !== startElem && 
                !endElem.classList.contains('connected') &&
                !startElem.classList.contains('connected'))  {
                console.log(`Connected ${startElem.id} to ${endElem.id}`);
            
                startElem.classList.add('connected');
                endElem.classList.add('connected');
    
                tempPath.setAttribute('data-connected-from', startElem.id);
                tempPath.setAttribute('data-connected-to', endElem.id);
    
                connectedPaths[startElem.id] = tempPath;
                connectedPaths[endElem.id] = tempPath;

                
                const connectionKey = startElem.id + "-" + endElem.id;
                connectedPaths[connectionKey] = tempPath;
            } else {
              document.getElementById('connectorContainer').removeChild(tempPath);
            }
    
            document.removeEventListener("mousemove", drawBezier);
            document.removeEventListener("mouseup", endConnection);
            document.removeEventListener("touchmove", drawBezier);
            document.removeEventListener("touchend", endConnection);
    
            startElem = null;
            tempPath = null;
        }
    
        document.querySelectorAll('.box').forEach(elem => {
            elem.addEventListener('mousedown', startConnection);
            elem.addEventListener('touchstart', startConnection);
        });
    
    function initializeAutoConnection() {
        const box1Elem = document.getElementById('box1');
        const box2Elem = document.getElementById('box2');
        
        if (box1Elem && box2Elem) {
            const path = connectElements(box1Elem, box2Elem);
            if (path) {
                path.setAttribute('data-connected-from', 'box1');
                path.setAttribute('data-connected-to', 'box2');
                box1Elem.classList.add('connected');
                box2Elem.classList.add('connected');
                connectedPaths['box1'] = path;
                connectedPaths['box2'] = path;
    
                // Add click event listener to the auto-connected path after it's appended to the SVG container
                setTimeout(() => {
                    path.addEventListener('click', function() {
                        const fromBoxId = this.getAttribute('data-connected-from');
                        const toBoxId = this.getAttribute('data-connected-to');
                        const fromBox = document.getElementById(fromBoxId);
                        const toBox = document.getElementById(toBoxId);
    
                        if (fromBox && toBox) {
                            fromBox.classList.remove('connected');
                            toBox.classList.remove('connected');
                            svgContainer.removeChild(this);
                            delete connectedPaths[fromBoxId];
                            delete connectedPaths[toBoxId];
                        }
                    });
                }, 0);
            }
        }
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        initializeAutoConnection();
    });
    
    document.querySelectorAll('.box').forEach(box => {
    box.addEventListener('click', function(e) {
        const boxId = e.target.id;
        const existingPathKey = Object.keys(connectedPaths).find(key => key.includes(boxId));
        console.log("Trying to remove connection with key:", existingPathKey); // キーをログに出力
        const existingPath = connectedPaths[existingPathKey];
        if (existingPath) {
            const [fromBoxId, toBoxId] = existingPathKey.split('-');
            
            const fromBox = document.getElementById(fromBoxId);
            const toBox = document.getElementById(toBoxId);
            
            if (fromBox) {
                fromBox.classList.remove('connected');
            }
            
            if (toBox) {
                toBox.classList.remove('connected');
            }
            
            if (existingPath && document.getElementById('connectorContainer').contains(existingPath)) {
                document.getElementById('connectorContainer').removeChild(existingPath);
            }
            delete connectedPaths[existingPathKey];
        }
    });
});
    
    window.addEventListener('DOMContentLoaded', (event) => {
        connectElements(document.getElementById('box1'), document.getElementById('box2'));
    });
    </script>

</body>

</html>
